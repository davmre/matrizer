module Optimization where

import qualified Data.Map as Map
import qualified Data.Set as Set

import Data.List

import Control.Monad
import Control.Monad.Error
import System.Environment

import MTypes
import Analysis

--------------------------------------------------------------------------------------------------------
-- Zipper definitions for the MTree structure (see http://learnyouahaskell.com/zippers) 

data Crumb = SingleCrumb UnOp | LeftCrumb BinOp MTree | RightCrumb BinOp MTree | TernCrumb TernOp [MTree] [MTree] deriving (Show)
type Breadcrumbs = [Crumb]

type MZipper = (MTree, Breadcrumbs)

goLeft :: MZipper -> Maybe MZipper
goLeft (Branch2 op l r, bs) = Just (l, LeftCrumb op r:bs)  
goLeft (Branch3 op l c r, bs) = Just (l, TernCrumb op [] [c,r] : bs)  
goLeft _ = Nothing

goRight :: MZipper -> Maybe MZipper
goRight (Branch2 op l r, bs) = Just (r, RightCrumb op l:bs)  
goRight (Branch3 op l c r, bs) = Just (r, TernCrumb op [l,c] [] : bs)  
goRight _ = Nothing

goDown :: MZipper -> Maybe MZipper
goDown (Branch1 op t, bs) = Just (t, SingleCrumb op : bs)
goDown (Branch3 op l c r, bs) = Just (c, TernCrumb op [l] [r] : bs)
goDown _ = Nothing

goUp :: MZipper -> Maybe MZipper
goUp (t, SingleCrumb op : bs) = Just (Branch1 op t, bs)
goUp (t, LeftCrumb op r : bs) = Just (Branch2 op t r, bs)
goUp (t, RightCrumb op l : bs) = Just (Branch2 op l t, bs)
goUp (t, TernCrumb op [] [c, r] : bs) = Just (Branch3 op t c r , bs)
goUp (t, TernCrumb op [l] [r] : bs) = Just (Branch3 op l t r , bs)
goUp (t, TernCrumb op [l,c] [] : bs) = Just (Branch3 op l c t , bs)

goUp _ = Nothing

topMost :: MZipper -> MZipper
topMost (t,[]) = (t,[])  
topMost z = topMost $ maybe z id (goUp z)  

modify :: (MTree -> Maybe MTree) -> MZipper -> MZipper  
modify f (t, bs) = case (f t) of
  Just a -> (a, bs)
  Nothing -> (t, bs)

zipperToTree :: MZipper -> MTree
zipperToTree (n, bs) = n

-----------------------------------------------------------------
-- Main optimizer logic


-- toplevel optimization function: first, call optimizeHelper to
--  get a list of all transformed versions of the current tree
--  (applying all rules at every node until no new trees are
--  produced). Second, calculate FLOPs for each of the transformed
--  trees (note technically the FLOPs calculation can fail, so we get
--  sketchyFLOPsList which is a list of ThrowsError Int, hence the
--  final fmap which deals with this).  Finally, sort the zipped
--  (flops, trees) list to get the tree with the smallest FLOP count,
--  and return that.
optimize :: MTree -> SymbolTable -> ThrowsError (Int, MTree)
optimize tree tbl = let (_, allTreesSet) = optimizeHelper tbl [tree] (Set.singleton tree)
                        allTreesList = Set.toList allTreesSet
                        sketchyFLOPsList = mapM (flip treeFLOPs tbl) allTreesList in
                    fmap (\ flopsList -> head $ sort $ zip flopsList allTreesList) sketchyFLOPsList


-- inputs: a list of still-to-be-transformed expressions, and a set of
-- all expressions that have already been generated by the
-- optimization rules

-- outputs: a new list of candidate expressions, constructed by
-- removing the first element of the previous list, and appending to
-- the end all legal transformations of that element that are not
-- already in the tabu set. also returns a augmented tabu set
-- containing all of the newly generated expressions (the same ones
-- that were added to the list)
type TabuSet = Set.Set MTree
optimizeHelper :: SymbolTable -> [MTree] -> TabuSet -> ([MTree], TabuSet)
optimizeHelper tbl [] exprSet = ([], exprSet)
optimizeHelper tbl (t:ts) exprSet = let generatedExprs = Set.fromList $ optimizerTraversal tbl (t, [])
                                        novelExprs = Set.difference generatedExprs exprSet in
                                    optimizeHelper tbl ( ts ++ (Set.toList novelExprs) ) (Set.union exprSet novelExprs)
  
-- Given a zipper corresponding to a position (node) in a tree, return
-- the list of all new trees constructable by applying a single
-- optimization rule either at the current node, or (recursively) at
-- any descendant node. Note: the transformed trees we return are
-- rooted at the toplevel, i.e. they have been 'unzipped' by
-- reconstructTree.
optimizerTraversal :: SymbolTable -> MZipper -> [MTree]
optimizerTraversal tbl (Leaf c, bs) = []
optimizerTraversal tbl z@( n@(Branch3 op l c r), bs) = (map (reconstructTree z) (optimizeAtNode tbl n) ) ++  
                                                       (maybe [] id (fmap (optimizerTraversal tbl) (goLeft z) )) ++
                                                       (maybe [] id (fmap (optimizerTraversal tbl) (goDown z) )) ++
                                                       (maybe [] id (fmap (optimizerTraversal tbl) (goRight z)))
optimizerTraversal tbl z@( n@(Branch2 op l r), bs) = (map (reconstructTree z) (optimizeAtNode tbl n) ) ++  
                                                     (maybe [] id (fmap (optimizerTraversal tbl) (goLeft z) )) ++
                                                     (maybe [] id (fmap (optimizerTraversal tbl) (goRight z)))
optimizerTraversal tbl z@( n@(Branch1 op t), bs) = (map (reconstructTree z) (optimizeAtNode tbl n) ) ++
                                                   (maybe [] id (fmap (optimizerTraversal tbl) (goDown z)))

-- Given a tree node, return a list of all transformed nodes that can
-- be generated by applying optimization rules at that node.
optimizeAtNode :: SymbolTable -> MTree -> [MTree]
optimizeAtNode tbl t = mapMaybeFunc t [f tbl | f <- optimizationRules]

-- Take a zipper representing a subtree, and a new subtree to replace that subtree. 
-- return a full (rooted) tree with the new subtree in the appropriate place. 
reconstructTree :: MZipper -> MTree -> MTree
reconstructTree (t1, bs) t2 = zipperToTree $ topMost (t2, bs)

-- Utility function used by optimizeAtNode: map a function f over a
-- list, silently discarding any element for which f returns Nothing.
mapMaybeFunc :: a -> [(a -> Maybe b)] -> [b]
mapMaybeFunc _ []     = []
mapMaybeFunc x (f:fs) = 
  case f x of
    Just y  -> y : mapMaybeFunc x fs
    Nothing -> mapMaybeFunc x fs

------------------------------------------------------------------
-- List of optimizations
--
-- An optimization is a function SymbolTable -> MTree -> Maybe
-- MTree. The input tree is assumed to be a subexpression. If the
-- optimization can apply to that subexpression, it returns the
-- transformed subexpression. Otherwise it returns Nothing.
--
-- Note that an optimization does not always need to be helpful:
-- optimizations which increase the number of required FLOPs will be
-- selected against, but are perfectly legal (and sometimes necessary
-- as intermediate steps). 
--
-- The major current restriction on optimizations is that they should
-- generate at most a finite group of results: thus 'right-multiply by
-- the identity' is not currently allowed as an optimization, since it
-- generates AI, AII, AIII, etc. and will thus yield an infinitely
-- large set of transformed expressions. This could be fixed in the
-- future by imposing a maximum search depth.
--
-- To add a new optimization: make sure to include it in the list of
-- optimizationRules. This list is consulted by optimizeNode to
-- generate all possible transformed versions of a subtree.

binopSumRules = [commonFactorLeft, commonFactorRight]
binopProductRules = [assocMult, invToLinsolve, mergeToTernaryProduct, factorInverse, factorTranspose]
ternProductRules = [splitTernaryProductLeftAssoc, splitTernaryProductRightAssoc]
inverseRules = [distributeInverse, swapInverseTranspose, cancelDoubleInverse]
transposeRules = [distributeTranspose, swapTransposeInverse]
optimizationRules = inverseRules ++ transposeRules ++ binopSumRules ++ binopProductRules ++ ternProductRules

assocMult tbl (Branch2 MProduct (Branch2 MProduct l c) r) = Just (Branch2 MProduct l (Branch2 MProduct c r))
assocMult tbl (Branch2 MProduct l (Branch2 MProduct c r)) = Just (Branch2 MProduct (Branch2 MProduct l c) r)
assocMult tbl _ = Nothing

commonFactorRight tbl (Branch2 MSum (Branch2 MProduct l1 l2) (Branch2 MProduct r1 r2)) = 
  if (l2 == r2) 
     then Just (Branch2 MProduct (Branch2 MSum l1 r1) l2)
     else Nothing
commonFactorRight tbl _ = Nothing

commonFactorLeft tbl (Branch2 MSum (Branch2 MProduct l1 l2) (Branch2 MProduct r1 r2)) = 
  if (l1 == r1) 
     then Just (Branch2 MProduct l1 (Branch2 MSum l2 r2))
     else Nothing
commonFactorLeft tbl _ = Nothing

invToLinsolve tbl (Branch2 MProduct (Branch1 MInverse l) r) = let Right (Matrix nr nc props) = treeMatrix l tbl in
                                                              if PosDef `elem` props
                                                              then Just (Branch2 MCholSolve l r)
                                                              else Just (Branch2 MLinSolve l r)
invToLinsolve tbl _ = Nothing               

mergeToTernaryProduct tbl (Branch2 MProduct (Branch2 MProduct l c) r) = Just (Branch3 MTernaryProduct l c r)
mergeToTernaryProduct tbl (Branch2 MProduct l (Branch2 MProduct c r)) = Just (Branch3 MTernaryProduct l c r)
mergeToTernaryProduct tbl _ = Nothing

splitTernaryProductLeftAssoc tbl (Branch3 MTernaryProduct l c r) = Just (Branch2 MProduct (Branch2 MProduct l c) r)
splitTernaryProductLeftAssoc tbl _ = Nothing

splitTernaryProductRightAssoc tbl (Branch3 MTernaryProduct l c r) = Just (Branch2 MProduct l (Branch2 MProduct c r))
splitTernaryProductRightAssoc tbl _ = Nothing

-- we can do (AB)^-1 = B^-1 A^-1 as long as A and B are both square
distributeInverse tbl (Branch1 MInverse (Branch2 MProduct l r)) = 
                  let Right (Matrix lr lc lprops) = treeMatrix l tbl
                      Right (Matrix rr rc rprops) = treeMatrix r tbl in
                  if (lr == lc) && (rr == rc)
                  then Just (Branch2 MProduct (Branch1 MInverse r) (Branch1 MInverse l))
                  else Nothing
distributeInverse tbl _ = Nothing

factorInverse tbl (Branch2 MProduct (Branch1 MInverse r) (Branch1 MInverse l)) = Just (Branch1 MInverse (Branch2 MProduct l r))
factorInverse tbl _ = Nothing

cancelDoubleInverse tbl (Branch1 MInverse (Branch1 MInverse t)) = Just t
cancelDoubleInverse tbl _ = Nothing 

distributeTranspose tbl (Branch1 MTranspose (Branch2 MProduct l r)) = Just (Branch2 MProduct (Branch1 MTranspose r) (Branch1 MTranspose l))
distributeTranspose tbl _ = Nothing

factorTranspose tbl (Branch2 MProduct (Branch1 MTranspose r) (Branch1 MTranspose l)) = Just (Branch1 MTranspose (Branch2 MProduct l r))
factorTranspose tbl _ = Nothing

swapInverseTranspose tbl (Branch1 MInverse (Branch1 MTranspose t)) = Just (Branch1 MTranspose (Branch1 MInverse t))
swapInverseTranspose tbl _ = Nothing 

swapTransposeInverse tbl (Branch1 MTranspose (Branch1 MInverse t)) = Just (Branch1 MInverse (Branch1 MTranspose t))
swapTransposeInverse tbl _ = Nothing 