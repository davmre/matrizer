module Optimization where

import qualified Data.Map as Map
import qualified Data.Set as Set

import Data.List

import MTypes
import Analysis

--------------------------------------------------------------------------------------------------------
-- Zipper definitions for the Expr structure (see http://learnyouahaskell.com/zippers)

data Crumb = SingleCrumb UnOp
           | LeftCrumb BinOp Expr
           | RightCrumb BinOp Expr
           | TernCrumb TernOp [Expr] [Expr]
           deriving (Show, Eq)
type Breadcrumbs = [Crumb]

type MZipper = (Expr, Breadcrumbs)

goLeft :: MZipper -> Maybe MZipper
goLeft (Branch2 op l r, bs) = Just (l, LeftCrumb op r:bs)
goLeft (Branch3 op l c r, bs) = Just (l, TernCrumb op [] [c,r] : bs)
goLeft _ = Nothing

goRight :: MZipper -> Maybe MZipper
goRight (Branch2 op l r, bs) = Just (r, RightCrumb op l:bs)
goRight (Branch3 op l c r, bs) = Just (r, TernCrumb op [l,c] [] : bs)
goRight _ = Nothing

goDown :: MZipper -> Maybe MZipper
goDown (Branch1 op t, bs) = Just (t, SingleCrumb op : bs)
goDown (Branch3 op l c r, bs) = Just (c, TernCrumb op [l] [r] : bs)
goDown _ = Nothing

goUp :: MZipper -> Maybe MZipper
goUp (t, SingleCrumb op : bs) = Just (Branch1 op t, bs)
goUp (t, LeftCrumb op r : bs) = Just (Branch2 op t r, bs)
goUp (t, RightCrumb op l : bs) = Just (Branch2 op l t, bs)
goUp (t, TernCrumb op [] [c, r] : bs) = Just (Branch3 op t c r , bs)
goUp (t, TernCrumb op [l] [r] : bs) = Just (Branch3 op l t r , bs)
goUp (t, TernCrumb op [l,c] [] : bs) = Just (Branch3 op l c t , bs)

goUp _ = Nothing

topMost :: MZipper -> MZipper
topMost (t,[]) = (t,[])
topMost z = topMost $ maybe z id (goUp z)

modify :: (Expr -> Maybe Expr) -> MZipper -> MZipper
modify f (t, bs) = case (f t) of
  Just a -> (a, bs)
  Nothing -> (t, bs)

zipperToTree :: MZipper -> Expr
zipperToTree (n, _) = n

-----------------------------------------------------------------
-- Main optimizer logic

optimizePrgm :: Stmt -> SymbolTable -> ThrowsError (Int, Stmt)
optimizePrgm (Assign v e) tbl = do (flops, eopt) <- optimizeExpr e tbl
                                   return $ (flops, Assign v eopt)
optimizePrgm (Seq x) tbl = do pairs <- mapM ((flip optimizePrgm) tbl) x
                              let (flops, stmts) = unzip pairs in
                                  return (sum flops, Seq stmts)

-- toplevel optimization function: first, call optimizeHelper to
--  get a list of all transformed versions of the current tree
--  (applying all rules at every node until no new trees are
--  produced). Second, calculate FLOPs for each of the transformed
--  trees (note technically the FLOPs calculation can fail, so we get
--  sketchyFLOPsList which is a list of ThrowsError Int, hence the
--  final fmap which deals with this).  Finally, sort the zipped
--  (flops, trees) list to get the tree with the smallest FLOP count,
--  and return that.
optimizeExpr :: Expr -> SymbolTable -> ThrowsError (Int, Expr)
optimizeExpr tree tbl = let (_, allTreesSet) = optimizeHelper tbl [tree] (Set.singleton tree)
                            allTreesList = Set.toList allTreesSet
                            sketchyFLOPsList = mapM (flip treeFLOPs tbl) allTreesList in
                        fmap (\ flopsList -> head $ sort $ zip flopsList allTreesList) sketchyFLOPsList


-- inputs: a list of still-to-be-transformed expressions, and a set of
-- all expressions that have already been generated by the
-- optimization rules

-- outputs: a new list of candidate expressions, constructed by
-- removing the first element of the previous list, and appending to
-- the end all legal transformations of that element that are not
-- already in the tabu set. also returns a augmented tabu set
-- containing all of the newly generated expressions (the same ones
-- that were added to the list)
type TabuSet = Set.Set Expr
optimizeHelper :: SymbolTable -> [Expr] -> TabuSet -> ([Expr], TabuSet)
optimizeHelper _ [] exprSet = ([], exprSet)
optimizeHelper tbl (t:ts) exprSet = let generatedExprs = Set.fromList $ optimizerTraversal tbl (t, [])
                                        novelExprs = Set.difference generatedExprs exprSet in
                                    optimizeHelper tbl ( ts ++ (Set.toList novelExprs) ) (Set.union exprSet novelExprs)

-- Given a zipper corresponding to a position (node) in a tree, return
-- the list of all new trees constructable by applying a single
-- optimization rule either at the current node, or (recursively) at
-- any descendant node. Note: the transformed trees we return are
-- rooted at the toplevel, i.e. they have been 'unzipped' by
-- reconstructTree.
optimizerTraversal :: SymbolTable -> MZipper -> [Expr]
optimizerTraversal _ (Leaf _, _) = []
optimizerTraversal tbl z@( n@(Branch3 _ _ _ _), _) =
        (map (reconstructTree z) (optimizeAtNode tbl n) ) ++
        (maybe [] id (fmap (optimizerTraversal tbl) (goLeft z) )) ++
        (maybe [] id (fmap (optimizerTraversal tbl) (goDown z) )) ++
        (maybe [] id (fmap (optimizerTraversal tbl) (goRight z)))
optimizerTraversal tbl z@( n@(Branch2 _ _ _), _) =
        (map (reconstructTree z) (optimizeAtNode tbl n) ) ++
        (maybe [] id (fmap (optimizerTraversal tbl) (goLeft z) )) ++
        (maybe [] id (fmap (optimizerTraversal tbl) (goRight z)))
optimizerTraversal tbl z@( n@(Branch1 _ _), _) =
        (map (reconstructTree z) (optimizeAtNode tbl n) ) ++
        (maybe [] id (fmap (optimizerTraversal tbl) (goDown z)))

-- Given a tree node, return a list of all transformed nodes that can
-- be generated by applying optimization rules at that node.
optimizeAtNode :: SymbolTable -> Expr -> [Expr]
optimizeAtNode tbl t = mapMaybeFunc t [f tbl | f <- optimizationRules]

-- Take a zipper representing a subtree, and a new subtree to replace that subtree.
-- return a full (rooted) tree with the new subtree in the appropriate place.
reconstructTree :: MZipper -> Expr -> Expr
reconstructTree (_, bs) t2 = zipperToTree $ topMost (t2, bs)

-- Utility function used by optimizeAtNode: map a function f over a
-- list, silently discarding any element for which f returns Nothing.
mapMaybeFunc :: a -> [(a -> Maybe b)] -> [b]
mapMaybeFunc _ []     = []
mapMaybeFunc x (f:fs) =
  case f x of
    Just y  -> y : mapMaybeFunc x fs
    Nothing -> mapMaybeFunc x fs

------------------------------------------------------------------
-- List of optimizations
--
-- An optimization is a function SymbolTable -> Expr -> Maybe
-- Expr. The input tree is assumed to be a subexpression. If the
-- optimization can apply to that subexpression, it returns the
-- transformed subexpression. Otherwise it returns Nothing.
--
-- Note that an optimization does not always need to be helpful:
-- optimizations which increase the number of required FLOPs will be
-- selected against, but are perfectly legal (and sometimes necessary
-- as intermediate steps).
--
-- The major current restriction on optimizations is that they should
-- generate at most a finite group of results: thus 'right-multiply by
-- the identity' is not currently allowed as an optimization, since it
-- generates AI, AII, AIII, etc. and will thus yield an infinitely
-- large set of transformed expressions. This could be fixed in the
-- future by imposing a maximum search depth.
--
-- To add a new optimization: make sure to include it in the list of
-- optimizationRules. This list is consulted by optimizeNode to
-- generate all possible transformed versions of a subtree.

-- TODO: Keeping everything in list is kind of ugly. Probably switch to
-- records.
-- TODO: If we switch to records, probably roll out a lens so that the
-- structure keeps (Expr -> Maybe Expr) but gives back (a -> Expr ->
-- Maybe Expr) (i.e. const) for e.g. binopSumRules. Then remove the
-- extra arguments that are cluttering everything.

type Rule  =  Map.Map Char Matrix -> Expr -> Maybe Expr
type Rules = [Rule]

binopSumRules :: Rules
binopSumRules = [commonFactorLeft
                , commonFactorRight
                ]

binopProductRules :: Rules
binopProductRules = [assocMult
                    , invToLinsolve
                    , mergeToTernaryProduct
                    , factorInverse
                    , factorTranspose
                    ]

ternProductRules :: Rules
ternProductRules = [splitTernaryProductLeftAssoc
                   , splitTernaryProductRightAssoc
                   ]

inverseRules :: Rules
inverseRules = [distributeInverse
               , swapInverseTranspose
               , cancelDoubleInverse
               ]

transposeRules :: Rules
transposeRules = [distributeTranspose
                 , swapTransposeInverse
                 ]

optimizationRules :: Rules
optimizationRules = inverseRules ++ transposeRules ++ binopSumRules ++
    binopProductRules ++ ternProductRules

assocMult :: Rule
assocMult _ (Branch2 MProduct (Branch2 MProduct l c) r) = Just (Branch2 MProduct l (Branch2 MProduct c r))
assocMult _ (Branch2 MProduct l (Branch2 MProduct c r)) = Just (Branch2 MProduct (Branch2 MProduct l c) r)
assocMult _ _ = Nothing

commonFactorRight :: Rule
commonFactorRight _ (Branch2 MSum (Branch2 MProduct l1 l2) (Branch2 MProduct r1 r2)) =
  if (l2 == r2)
     then Just (Branch2 MProduct (Branch2 MSum l1 r1) l2)
     else Nothing
commonFactorRight _ _ = Nothing

commonFactorLeft :: Rule
commonFactorLeft _ (Branch2 MSum (Branch2 MProduct l1 l2) (Branch2 MProduct r1 r2)) =
  if (l1 == r1)
     then Just (Branch2 MProduct l1 (Branch2 MSum l2 r2))
     else Nothing
commonFactorLeft _ _ = Nothing

invToLinsolve :: Rule
invToLinsolve tbl (Branch2 MProduct (Branch1 MInverse l) r) =
        let Right (Matrix _ _ props) = treeMatrix l tbl in
            if PosDef `elem` props
                then Just (Branch2 MCholSolve l r)
                else Just (Branch2 MLinSolve l r)
invToLinsolve _ _ = Nothing

mergeToTernaryProduct :: Rule
mergeToTernaryProduct _ (Branch2 MProduct (Branch2 MProduct l c) r) =
        Just (Branch3 MTernaryProduct l c r)
mergeToTernaryProduct _ (Branch2 MProduct l (Branch2 MProduct c r)) =
        Just (Branch3 MTernaryProduct l c r)
mergeToTernaryProduct _ _ = Nothing

splitTernaryProductLeftAssoc :: Rule
splitTernaryProductLeftAssoc _ (Branch3 MTernaryProduct l c r) =
        Just (Branch2 MProduct (Branch2 MProduct l c) r)
splitTernaryProductLeftAssoc _ _ = Nothing

splitTernaryProductRightAssoc :: Rule
splitTernaryProductRightAssoc _ (Branch3 MTernaryProduct l c r) =
        Just (Branch2 MProduct l (Branch2 MProduct c r))
splitTernaryProductRightAssoc _ _ = Nothing

-- we can do (AB)^-1 = B^-1 A^-1 as long as A and B are both square
distributeInverse :: Rule
distributeInverse tbl (Branch1 MInverse (Branch2 MProduct l r)) =
                  let Right (Matrix lr lc _) = treeMatrix l tbl
                      Right (Matrix rr rc _) = treeMatrix r tbl in
                  if (lr == lc) && (rr == rc)
                  then Just (Branch2 MProduct (Branch1 MInverse r)
                                              (Branch1 MInverse l))
                  else Nothing
distributeInverse _ _ = Nothing

factorInverse :: Rule
factorInverse _ (Branch2 MProduct (Branch1 MInverse r) (Branch1 MInverse l)) =
        Just (Branch1 MInverse (Branch2 MProduct l r))
factorInverse _ _ = Nothing

cancelDoubleInverse ::Rule
cancelDoubleInverse _ (Branch1 MInverse (Branch1 MInverse t)) = Just t
cancelDoubleInverse _ _ = Nothing

distributeTranspose :: Rule
distributeTranspose _ (Branch1 MTranspose (Branch2 MProduct l r)) =
        Just (Branch2 MProduct (Branch1 MTranspose r) (Branch1 MTranspose l))
distributeTranspose _ _ = Nothing

factorTranspose :: Rule
factorTranspose _ (Branch2 MProduct (Branch1 MTranspose r) (Branch1 MTranspose l)) =
        Just (Branch1 MTranspose (Branch2 MProduct l r))
factorTranspose _ _ = Nothing

swapInverseTranspose :: Rule
swapInverseTranspose _ (Branch1 MInverse (Branch1 MTranspose t)) =
        Just (Branch1 MTranspose (Branch1 MInverse t))
swapInverseTranspose _ _ = Nothing

swapTransposeInverse :: Rule
swapTransposeInverse _ (Branch1 MTranspose (Branch1 MInverse t)) =
        Just (Branch1 MInverse (Branch1 MTranspose t))
swapTransposeInverse _ _ = Nothing
